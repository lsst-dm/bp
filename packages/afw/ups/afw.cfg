# -*- python -*-
"""
Dependencies and configuration for afw.
"""
import os.path

def _get_root():
    """Return the root directory of the package."""
    ups = os.path.dirname(__file__)
    return os.path.abspath(os.path.join(ups, ".."))

dependencies = {
    # Names of packages required to build against this package.
    "required": ["base", "bputils", "pex_exceptions", "utils", "daf_base", "pex_logging", "security",
                 "pex_policy", "daf_persistence", "daf_data", "eigen", "fftw", "ndarray", "numpy",
                 "minuit2", "xpa", "wcslib", "gsl", "cfitsio",
                 "boost_regex", "boost_filesystem", "boost_serialization"],

    # Names of packages optionally setup when building against this package.
    "optional": [],

    # Names of packages required to build this package, but not required to build against it.
    "buildRequired": ["boost_test"],

    # Names of packages optionally setup when building this package, but not used in building against it.
    "buildOptional": ["afwdata"],

    }

def setup(conf, products, build=False):
    """
    Update an SCons environment to make use of the package.

    Arguments:
     conf ------ An SCons Configure context.  The SCons Environment conf.env should be updated
                 by the setup function.
     products -- A dictionary consisting of all dependencies and the return values of calls to their
                 setup() functions, or None if the dependency was optional and was not found.
     build ----- If True, this is the product currently being built, and products in "buildRequired" and
                 "buildOptional" dependencies will also be present in the products dict.
    """
    conf.env.PrependUnique(**paths)
    if not build:
        conf.env.AppendUnique(**doxygen)
    for target in libs:
        if target not in conf.env.libs:
            conf.env.libs[target] = lib[target].copy()
        else:
            for lib in libs[target]:
                if lib not in conf.env.libs[target]:
                    conf.env.libs[target].append(lib)
    return {"paths": paths, "doxygen": doxygen, "libs": libs, "extra": {}}


###################################################################################################
# Variables for default implementation of setup() below; if the user provides 
# a custom implementation of setup(), everything below is unnecessary.

# Packages to be added to the environment.
paths = {
    # Sequence of paths to add to the include path.
    "CPPPATH": [os.path.join(_get_root(), "include")],

    # Sequence of paths to add to the linker path.
    "LIBPATH": [os.path.join(_get_root(), "lib")],
    
    }

doxygen = {
    # Sequence of Doxygen tag files produced by this product.
    "DOXYGEN_TAGFILES": [os.path.join(_get_root(), "doc", "afw.tag")],

    # Sequence of Doxygen configuration files to include in dependent products.
    "DOXYGEN_INCLUDES": [],

    }

# Libraries provided or used by the package, not including standard library prefixes or suffixes.
# Additional custom targets besides the standard "main", "python", and "test" targets may
# be provided as well.
libs = {
    # Normal libraries.
    "main": ["afw", "m"],

    # Libraries only linked with C++-coded Python modules.
    "python": [],
    
    # Libraries only linked with C++-coded unit tests.
    "test": [],

    }

